# PaymentGateway

**Api endpoints:**
*The endpings are available via Swagger*
- Payment can be done using /api/Payment POST method, where the data must be in json format provided as body of the request
- Previous payment can be accessed using /api/Payment GET method, where the input parameter is the Id of the payment(which is generated by the Payment Gateway, or by the Bank id (which is provided by the bank)


**Validation rules:**
- CardNumber
  - Not Empty 
  - CreditCard Number format

- Expiry Month
  - Not Empty integer
  - Betweeb 1 and 12

- ExpiryYear
  - Not Empty integer
  - Between 2019 and 2040

- Currency
  - Not Empty string
  - 3 characters

- Amount (In Cents)
  - Not Empty integer

- Cvv
  - Not Empty
  - 3 characters

Example input:
```
{
  "cardNumber": "4716286534933447",
  "expiryMonth": 10,
  "expiryYear": 2019,
  "amountInCents": 100000,
  "currency": "GBP",
  "cvv": 123
}
```

The solution is made of 4 projects. Model doesn't have dependency. Clients and PaymentTests depend on Model, and finally, WebApi depends on Model and Client. This requires IBankClient to be in Model project, although the implementation is in Clients project.

The latency between the bank and the Payment Gateway is symulated by a 1 second delay within FakeBankClient. FakeBankClient also has a 50-50% chance to accept or reject the request.

Tests use 2 other clients, one accepts all payments, the other one rejects all. I chose to add this classes instead of using Moq or NSubstitute, so they can be injected into the running system if needed.
